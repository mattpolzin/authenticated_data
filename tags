!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
(	Auth.idr	/^  (::) : a -> Foorp a -> Foorp a$/;"	d
Auth	Auth1.idr	/^data Auth : Hashable b => Type -> Type where$/;"	t
AuthList	Auth2.idr	/^  data AuthList : Type -> Type where$/;"	t
Authed	Auth1.idr	/^  Authed : Projectable v b => v -> Auth v {b}$/;"	d
CAuthed	Auth.idr	/^  CAuthed : (SecureHashable a, Foldable t) => t Hash -> Client t a$/;"	d
Client	Auth.idr	/^data Client : (Type -> Type) -> Type -> Type where$/;"	t
Cons	Auth.idr	/^    Cons : SecureHashable a => a -> Foorp a -> Foorp a$/;"	d
Cons	Auth.idr	/^  Cons : SecureHashable a => a -> Proof a -> Proof a$/;"	d
Cons	Auth1.idr	/^  Cons : Projectable a b => b -> Proof b -> Proof b$/;"	d
Cons	Auth2.idr	/^    Cons : a -> Prover.Elem (AuthList a) -> AuthList a$/;"	d
Cons	Auth2.idr	/^  Cons : Projectable a b => b -> Proof b -> Proof b$/;"	d
Elem	Auth.idr	/^  data Elem : a -> Type where$/;"	t
Elem	Auth1.idr	/^  data Elem : a -> Type where$/;"	t
Elem	Auth2.idr	/^  data Elem : a -> Type where$/;"	t
Fold	Auth.idr	/^Fold : Foldable t => (b : Type) -> (Monoid b, Projectable a b) => Projectable (t a) b$/;"	d
Fold	Auth2.idr	/^Fold : Foldable t => (b : Type) -> (Monoid b, Projectable a b) => Projectable (t a) b$/;"	d
Foorp	Auth.idr	/^  data Foorp : (a : Type) -> Type where$/;"	t
Full	Auth1.idr	/^    Full : (hash : Hash) -> (value : a) -> Elem a$/;"	d
Full	Auth2.idr	/^    Full : (hash : Hash) -> (value : a) -> Elem a$/;"	d
Hashed	Auth.idr	/^    Hashed : Hash -> a -> Elem a$/;"	d
Nil	Auth.idr	/^    Nil  : SecureHashable a => Foorp a$/;"	d
Nil	Auth.idr	/^  Nil  : SecureHashable a => Proof a$/;"	d
Nil	Auth1.idr	/^  Nil  : Projectable a b => Proof b$/;"	d
Nil	Auth2.idr	/^    Nil : AuthList a$/;"	d
Nil	Auth2.idr	/^  Nil  : Projectable a b => Proof b$/;"	d
Proof	Auth.idr	/^data Proof : (a : Type) -> Type where$/;"	t
Proof	Auth1.idr	/^data Proof : (b : Type) -> Type where$/;"	t
Proof	Auth2.idr	/^data Proof : (b : Type) -> Type where$/;"	t
SAuthed	Auth.idr	/^  SAuthed : (SecureHashable a, Foldable t) => t (Prover.Elem a) -> Server t a$/;"	d
Server	Auth.idr	/^data Server : (Type -> Type) -> Type -> Type where$/;"	t
Unauth	Auth1.idr	/^data Unauth : Hashable b => Type -> Type where$/;"	t
Unauthed	Auth1.idr	/^  Unauthed : Projectable v b => v -> Unauth v {b}$/;"	d
auth	Auth.idr	/^  auth : (SecureHashable b, Projectable a b) => (context : Foorp b) -> a -> (Foorp b, Elem a)$/;"	d
auth	Auth.idr	/^  auth : SecureHashable a => (context : Proof a) -> a -> (Proof a, Hash)$/;"	d
auth	Auth1.idr	/^  auth : Hashable a => a -> Hash$/;"	d
auth	Auth1.idr	/^  auth : {auto proj : Projectable a b} -> Hashable b => a -> Elem a$/;"	d
auth	Auth2.idr	/^  auth : Hashable a => a -> Hash$/;"	d
auth	Auth2.idr	/^  auth : {auto proj : Projectable a b} -> Hashable b => a -> Elem a$/;"	d
auth'	Auth.idr	/^  auth' : (SecureHashable b, Projectable a b) => a -> Elem a$/;"	d
authList	Auth2.idr	/^  authList : {a : Type} -> (Hashable a, Monoid a) => List a -> AuthList a$/;"	d
authValue	Auth1.idr	/^  authValue : Hashable b => (context : Proof b) -> b -> (Proof b, Hash)$/;"	d
authValue	Auth2.idr	/^  authValue : Hashable b => (context : Proof b) -> b -> (Proof b, Hash)$/;"	d
authedFive	Auth.idr	/^  authedFive : Maybe (Proof Int, Int)$/;"	d
authedGood	Auth.idr	/^  authedGood : Maybe (Proof String, String)$/;"	d
authedIndex	Auth.idr	/^  authedIndex : (n : Nat) -> (Server List a) -> Maybe (Proof a, a)$/;"	d
authedIndex	Auth2.idr	/^  authedIndex : {a : Type} -> Monoid a => (n : Nat) -> (xs : AuthList a) -> Maybe (Proof a, a)$/;"	d
authedIndex'	Auth.idr	/^      authedIndex' : (n : Nat) -> (context : Foorp a) -> List (Elem a) -> Maybe (Foorp a, a)$/;"	d
authedIndex'	Auth2.idr	/^      authedIndex' : (n : Nat) -> (context : Proof a) -> (xs : AuthList a) -> Maybe (Proof a, a)$/;"	d
authedSix	Auth.idr	/^  authedSix : Maybe (Proof Int, Int)$/;"	d
clientList	Auth.idr	/^  clientList : Client List Int$/;"	d
clientList	Auth.idr	/^  clientList : Client List String$/;"	d
clientList2	Auth.idr	/^  clientList2 : Client List Int$/;"	d
elem	Auth.idr	/^      elem : (Hash, a) -> Elem a$/;"	d
empty	Auth.idr	/^  empty : SecureHashable a => Foorp a$/;"	d
fromFoorp	Auth.idr	/^  fromFoorp : Foorp a -> Proof a$/;"	d
fromFoorp'	Auth.idr	/^  fromFoorp' : (first : a) -> (rest : Foorp a) -> (acc : Proof a) -> Proof a$/;"	d
fromList	Auth.idr	/^  fromList : SecureHashable a => List a -> Client List a$/;"	d
fromList	Auth.idr	/^  fromList : {auto hashable : SecureHashable a} -> List a -> Server List a$/;"	d
hash	Auth.idr	/^  hash : ty -> Hash$/;"	d
hash	Auth1.idr	/^  hash : a -> Hash$/;"	d
hash	Auth2.idr	/^  hash : a -> Hash$/;"	d
identityProjection	Auth.idr	/^identityProjection : Projectable a a$/;"	d
identityProjection	Auth2.idr	/^identityProjection : Projectable a a$/;"	d
learn	watch_and_learn.sh	/^function learn() {$/;"	f
list1	Auth.idr	/^  list1 : List Int$/;"	d
list1	Auth.idr	/^  list1 : List String$/;"	d
list1	Auth1.idr	/^list1 : List String$/;"	d
list1	Auth2.idr	/^  list1 : AuthList String$/;"	d
list1	Auth2.idr	/^list1 : List String$/;"	d
list2	Auth1.idr	/^list2: Prover.Elem (List String)$/;"	d
list2	Auth2.idr	/^list2: Prover.Elem (List String)$/;"	d
list3	Auth2.idr	/^list3 : List (Prover.Elem String)$/;"	d
list4	Auth2.idr	/^list4 : Prover.Elem (List (Prover.Elem String))$/;"	d
prove	Auth1.idr	/^  prove : {auto proj : Projectable a b} -> (context : Proof b) -> a -> (Proof b, Elem a)$/;"	d
prove	Auth2.idr	/^  prove : Hashable b => {auto proj : Projectable a b} -> (context : Proof b) -> a -> (Proof b, Elem a)$/;"	d
res1	Auth1.idr	/^res1 : (Proof String, Prover.Elem String)$/;"	d
res1	Auth2.idr	/^res1 : (Proof String, Prover.Elem String)$/;"	d
serverList	Auth.idr	/^  serverList : Server List Int$/;"	d
serverList	Auth.idr	/^  serverList : Server List String$/;"	d
serverList2	Auth.idr	/^  serverList2 : Server List Int$/;"	d
shallowProjection	Auth.idr	/^  shallowProjection : a -> b$/;"	d
shallowProjection	Auth1.idr	/^  shallowProjection : a -> b$/;"	d
shallowProjection	Auth2.idr	/^  shallowProjection : a -> b$/;"	d
snoc	Auth1.idr	/^snoc : {auto proj : Projectable a b} -> Proof b -> b -> Proof b$/;"	d
snoc	Auth2.idr	/^snoc : {auto proj : Projectable a b} -> Proof b -> b -> Proof b$/;"	d
unauth	Auth.idr	/^  unauth : (Projectable a b) => (context : Foorp b) -> Elem a -> (Foorp b, a)$/;"	d
unauth	Auth.idr	/^  unauth : (context : Proof a) -> Hash -> Maybe (Proof a, a)$/;"	d
unauth	Auth1.idr	/^  unauth : Elem a -> a$/;"	d
unauth	Auth2.idr	/^  unauth : Elem a -> a$/;"	d
unauthElem	Auth1.idr	/^  unauthElem : {auto proj : Projectable a b} -> (Proof b, Elem a) -> (Proof b, a)$/;"	d
unauthElem	Auth2.idr	/^  unauthElem : {auto proj : Projectable a b} -> (Proof b, Elem a) -> (Proof b, a)$/;"	d
verifiedFive	Auth.idr	/^  verifiedFive : Maybe Int$/;"	d
verifiedGood	Auth.idr	/^  verifiedGood : Maybe String$/;"	d
verifiedIndex	Auth.idr	/^  verifiedIndex : (n : Nat) -> (clientCert : Client List a) -> (serverProof : Proof a) -> Maybe a$/;"	d
verifiedSix	Auth.idr	/^  verifiedSix : Maybe Int$/;"	d
verify	Auth1.idr	/^  verify : Hashable b => Proof b -> Hash -> Maybe (Proof b, b)$/;"	d
verify	Auth2.idr	/^  verify : Hashable b => Proof b -> Hash -> Maybe (Proof b, b)$/;"	d
watch	watch_and_learn.sh	/^function watch() {$/;"	f
x	Auth.idr	/^  x :: Nil = Cons x Nil$/;"	d
x	Auth.idr	/^  x :: xs@(Cons y z) = Cons x xs$/;"	d
||	Auth.idr	/^  ||| Foorp is a reversed Proof stream.$/;"	c
